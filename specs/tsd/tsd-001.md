---
id: tsd-001
status: draft
type: design
source_prd: prd-001
created: 2025-09-30T08:08:53.022Z
updated: 2025-09-30T08:08:53.022Z
---

# 系統架構概覽

CasualTrader 即時股價 MCP Server 採用分層架構設計，包含 MCP 協議層、業務邏輯層、資料存取層和外部 API 整合層。系統遵循 Model Context Protocol 標準，提供標準化的工具介面供客戶端應用程式呼叫。

整體架構採用事件驅動設計模式，支援非同步處理和並發請求。透過模組化設計確保各層職責清晰、易於測試和維護。

## 技術堆疊選擇

### 後端技術

- **執行環境**：Python 3.11+，透過 uvx 本地執行
- **套件管理**：uv，提供極快速的 Python 套件管理和虛擬環境
- **MCP 框架**：mcp Python SDK，官方 MCP Python 實作函式庫
- **HTTP 客戶端**：httpx，處理非同步 HTTP 請求
- **資料驗證**：Pydantic v2，提供資料模型驗證和序列化
- **非同步處理**：asyncio，支援高效能非同步程式設計
- **日誌系統**：loguru，提供簡潔的日誌記錄 (本地檔案輸出)
- **測試框架**：pytest + pytest-asyncio，進行非同步測試
- **程式碼品質**：ruff，整合 linting 和 formatting 功能
- **專案配置**：pyproject.toml，定義專案相依性和 uvx 執行點

### 資料快取設計

- **快取層**：Python 內建記憶體快取 (使用 cachetools 或 functools.lru_cache)
- **快取策略**：
  - TTL (Time To Live) 設定為 30 秒，平衡資料即時性與 API 呼叫頻率
  - 快取命中時直接回傳，避免重複 API 呼叫
  - 快取失效時才進行新的 API 請求
- **頻率控制快取**：記錄每個股票代號的最後請求時間
- **本地儲存**：避免外部資料庫相依性，簡化本地部署

### API 呼叫頻率控制

```python
from collections import defaultdict
from datetime import datetime, timedelta
from asyncio import Semaphore
import time

class RateLimiter:
    def __init__(self):
        # 每個股票代號的最後請求時間
        self.last_request_time = defaultdict(float)
        # 全域請求計數器 (滑動視窗)
        self.request_timestamps = []
        # 每秒請求限制信號量
        self.per_second_semaphore = Semaphore(2)
        
    async def can_request(self, symbol: str) -> bool:
        """檢查是否可以對特定股票代號發起 API 請求"""
        now = time.time()
        
        # 檢查該股票代號的請求間隔 (30秒限制)
        if now - self.last_request_time[symbol] < 30:
            return False
            
        # 檢查全域每分鐘請求次數 (20次限制)
        minute_ago = now - 60
        self.request_timestamps = [t for t in self.request_timestamps if t > minute_ago]
        if len(self.request_timestamps) >= 20:
            return False
            
        return True
        
    async def record_request(self, symbol: str):
        """記錄 API 請求"""
        now = time.time()
        self.last_request_time[symbol] = now
        self.request_timestamps.append(now)
```

- **資料結構**：

  ```python
  from pydantic import BaseModel
  from datetime import datetime
  from typing import List, Optional

  class StockData(BaseModel):
      symbol: str
      current_price: float
      volume: int
      open_price: float
      high_price: float
      low_price: float
      previous_close: float
      update_time: datetime
      # ... 其他欄位
  ```

## API 規格設計

### 核心 API 端點

**MCP 工具定義**：

```python
from mcp.types import Tool
from pydantic import BaseModel, Field

class GetStockPriceArgs(BaseModel):
    symbol: str = Field(
        description="台灣股票代號 (例如: 2330)",
        pattern=r"^[0-9]{4}$"
    )

@app.tool()
async def get_taiwan_stock_price(symbol: str) -> dict:
    """取得台灣股票即時價格資訊"""
    # 實作邏輯
    pass
```

### 資料格式

**請求格式**：

```json
{
  "name": "get_taiwan_stock_price",
  "arguments": {
    "symbol": "2330"
  }
}
```

**回應格式** (使用 Pydantic 模型)：

```python
class StockPriceResponse(BaseModel):
    symbol: str
    company_name: str
    current_price: float
    change: float
    change_percent: float
    volume: int
    open_price: float
    high_price: float
    low_price: float
    previous_close: float
    upper_limit: float
    lower_limit: float
    bid_prices: List[float]
    bid_volumes: List[int]
    ask_prices: List[float]
    ask_volumes: List[int]
    update_time: datetime
    last_trade_time: str
```

## 安全機制

- **輸入驗證**：嚴格驗證股票代號格式 (4位數字)
- **API 頻率限制**：多層次 Rate Limiting 保護機制
  - 每個股票代號：每 30 秒最多 1 次 API 呼叫
  - 全域限制：每分鐘最多 20 次 API 請求
  - 每秒限制：最多 2 次 API 請求 (避免瞬間爆發)
- **快取優先策略**：優先回傳快取資料，減少 API 呼叫
- **錯誤處理**：包裝外部 API 錯誤，避免洩露內部實作細節
- **資料清理**：對外部 API 回傳資料進行清理和驗證
- **HTTPS 強制**：所有對外請求均使用 HTTPS 協議

## 效能需求

- **回應時間**：95% 的請求在 2 秒內完成回應
- **並發處理**：支援同時處理 50 個併發請求
- **記憶體使用**：系統記憶體使用量不超過 512MB
- **CPU 使用率**：正常負載下 CPU 使用率不超過 50%
- **快取命中率**：達到 80% 以上的快取命中率

## 部署架構

### uvx 本地執行配置

- **執行方式**：使用 uvx 直接執行 MCP Server，無需容器化或複雜部署
- **命令範例**：`uvx --from . casualtrader-mcp-server`
- **環境隔離**：uvx 自動建立獨立的虛擬環境，避免系統套件衝突
- **快速啟動**：uv 的極速套件安裝，首次啟動時間大幅縮短

### pyproject.toml 配置範例

```toml
[project]
name = "casualtrader-mcp-server"
version = "0.1.0"
description = "台灣股價即時查詢 MCP Server (含 API 頻率限制)"
dependencies = [
    "mcp>=1.0.0",
    "httpx>=0.25.0",
    "pydantic>=2.0.0",
    "cachetools>=5.0.0",
    "loguru>=0.7.0"
]

[project.scripts]
casualtrader-mcp-server = "casualtrader_mcp:main"
```

### MCP 客戶端整合

- **Claude Desktop 設定**：在客戶端配置檔案中指向本地 uvx 命令
- **VS Code 整合**：透過 MCP 擴充功能連接本地服務
- **設定管理**：使用環境變數或設定檔案管理 API 端點和參數
- **日誌管理**：本地檔案日誌輸出，便於開發和除錯

## 相依性管理

- **外部相依性**：
  - 台灣證交所 API (`mis.twse.com.tw`)
  - MCP Python SDK (`mcp`)
  - HTTP 客戶端函式庫 (`httpx`)
  - 資料驗證函式庫 (`pydantic`)
  - 記憶體快取函式庫 (`cachetools`)
  - 日誌函式庫 (`loguru`)
  - 非同步控制函式庫 (`asyncio` - 內建)

- **API 整合策略**：
  - 實作重試機制，最多重試 3 次 (指數退避延遲)
  - 設定適當的超時時間 (5 秒)
  - 監控外部 API 可用性和回應時間
  - **頻率控制整合**：
    - 請求前檢查頻率限制，超過限制時直接回傳快取資料
    - 429 (Too Many Requests) 錯誤時增加延遲時間
    - 記錄 API 呼叫統計，便於調整頻率限制參數

## 錯誤處理策略

- **錯誤分類**：
  - 客戶端錯誤：無效股票代號、參數格式錯誤
  - 伺服器錯誤：外部 API 不可用、內部處理錯誤
  - 網路錯誤：連線超時、DNS 解析失敗
  - 頻率限制錯誤：API 呼叫過於頻繁、達到速率限制

- **錯誤回應格式**：

```python
class ErrorResponse(BaseModel):
    error: ErrorDetail

class ErrorDetail(BaseModel):
    code: str
    message: str
    details: Optional[dict] = None

# 範例錯誤回應
## 無效股票代號
{
  "error": {
    "code": "INVALID_SYMBOL",
    "message": "股票代號格式無效，請提供 4 位數字",
    "details": {
      "provided": "23a0",
      "expected": "四位數字，例如：2330"
    }
  }
}

## API 頻率限制
{
  "error": {
    "code": "RATE_LIMITED",
    "message": "API 呼叫過於頻繁，請稍後再試",
    "details": {
      "retry_after": 25,
      "last_cache_data": "2025-09-30T14:30:00Z"
    }
  }
}
```

## 測試策略

- **單元測試**：使用 pytest 進行測試，覆蓋率達到 90% 以上
- **非同步測試**：使用 pytest-asyncio 測試非同步功能
- **整合測試**：測試 MCP 協議整合、外部 API 呼叫
- **模擬測試**：使用 pytest-mock 或 responses 模擬外部 API 回應
- **端對端測試**：模擬真實客戶端呼叫場景
- **效能測試**：使用 pytest-benchmark 驗證效能需求
- **錯誤情境測試**：測試各種異常狀況的處理機制

## 開發里程碑

- **第一階段** (1-2 週)：Python MCP 伺服器基礎架構建立
  - 設定 uv 專案環境和 pyproject.toml 配置
  - 實作 MCP 協議基本架構，使用 Python MCP SDK
  - 建立專案目錄結構和 uvx 執行點設定
  - 設定 Pydantic 資料模型和驗證

- **第二階段** (2-3 週)：外部 API 整合
  - 使用 httpx 整合台灣證交所 API
  - 實作非同步資料解析和轉換邏輯
  - 建立 Python 異常處理機制
  - 實作資料驗證和清理功能

- **第三階段** (1-2 週)：快取和頻率控制最佳化
  - 實作本地記憶體快取策略和 API 頻率限制機制
  - 實作多層次 Rate Limiting (股票別、全域、每秒限制)
  - 建立快取優先策略和頻率控制日誌
  - asyncio 併發處理最佳化和效能基準測試

- **第四階段** (1 週)：測試和本地部署
  - 完成 pytest 單元測試和整合測試
  - 設定 uvx 本地執行和 MCP 客戶端整合
  - 撰寫本地部署文件和使用說明
  - 建立 Claude Desktop 等 MCP 客戶端配置範例
